import { StatusBar } from 'expo-status-bar';
import { StyleSheet, View, Text } from 'react-native';
import { WebView } from 'react-native-webview';
import { Asset } from 'expo-asset';
import * as FileSystem from 'expo-file-system';
import { useState, useEffect, useRef } from 'react';
import { minimalRouter } from './src/server/minimalRouter';
import { createPostMessageHandler } from '@elasticbottle/trpc-post-message/adapter';

export default function App() {
  const [htmlUri, setHtmlUri] = useState<string | null>(null);
  const [serverReady, setServerReady] = useState(false); // Start as false
  const [status, setStatus] = useState('Setting up server...');
  const webViewRef = useRef<WebView>(null);
  const messageHandlerRef = useRef<any>(null);

  useEffect(() => {
    async function loadHtml() {
      try {
        const asset = Asset.fromModule(require('./assets/web/index.html'));
        await asset.downloadAsync();

        const fileUri = `${FileSystem.documentDirectory}index.html`;
        await FileSystem.copyAsync({
          from: asset.localUri!,
          to: fileUri
        });

        setHtmlUri(fileUri.startsWith('file://') ? fileUri : `file://${fileUri}`);
        if (serverReady) {
          setStatus('Ready for testing');
        } else {
          setStatus('HTML loaded, waiting for server...');
        }
      } catch (error) {
        console.error('Error loading HTML:', error);
        setStatus('Error loading HTML');
      }
    }

    loadHtml();
  }, []);

  // Set up official tRPC server handler
  useEffect(() => {
    console.log('Setting up official tRPC server...');

    try {
      // Create official tRPC server handler
      createPostMessageHandler({
        router: minimalRouter,
        postMessage: ({ message }) => {
          console.log('Sending tRPC response:', message);
          if (webViewRef.current) {
            // Clean up the message by removing undefined values
            const cleanMessage = JSON.parse(JSON.stringify(message));

            // Send via both postMessage and direct JavaScript execution
            webViewRef.current.postMessage(JSON.stringify(cleanMessage));
          } else {
            console.error('webViewRef.current is null when trying to send response');
          }
        },
        addEventListener: (listener) => {
          console.log('Setting up tRPC message listener');
          messageHandlerRef.current = listener;
          return listener;
        },
        createContext: ({ req }) => {
          // Optional: add context data available to all procedures
          return {
            event: req,
            timestamp: new Date().toISOString()
          };
        },
        onError: ({ error, path }) => {
          console.error(`tRPC error on ${path}:`, error);
        }
      });

      console.log('Official tRPC server ready');
      setServerReady(true);

      if (htmlUri) {
        setStatus('Ready for testing');
      } else {
        setStatus('Server ready - Loading HTML...');
      }

    } catch (error) {
      console.error('Error setting up official tRPC server:', error);
      setStatus('Server setup failed');
    }
  }, []);

  const handleMessage = (event: any) => {
    try {
      const data = JSON.parse(event.nativeEvent.data);
      console.log('Received from WebView:', data);

      // Handle console messages from WebView
      if (data.type === 'console') {
        console.log(`[WebView ${data.level}]:`, data.message);
        return;
      }

      // Route tRPC requests to the official tRPC server handler
      if (messageHandlerRef.current) {
        console.log('Routing to official tRPC handler:', data);

        // The official handler expects a MessageEvent-like object
        const messageEvent = {
          data: data,
          origin: 'webview', // We trust our own WebView
          source: null,
          ports: []
        } as MessageEvent;

        try {
          messageHandlerRef.current(messageEvent);
        } catch (error) {
          console.error('Error calling official tRPC handler:', error);
        }
      } else {
        console.error('tRPC handler not ready - messageHandlerRef.current is null');
        console.error('serverReady state:', serverReady);
      }
    } catch (error) {
      console.error('Error parsing message:', error);
    }
  };

  return (
    <View style={styles.container}>
      <StatusBar style="light" />

      <View style={styles.header}>
        <Text style={styles.title}>tRPC Minimal Test</Text>
        <Text style={styles.status}>Status: {status}</Text>
        <Text style={styles.info}>Server Ready: {serverReady ? '✅' : '❌'}</Text>
        <Text style={styles.info}>HTML URI: {htmlUri ? '✅' : '❌'}</Text>
      </View>

      {htmlUri && serverReady && (
        <WebView
          ref={webViewRef}
          style={styles.webview}
          source={{ uri: htmlUri }}
          originWhitelist={['file://*', '*']}
          allowFileAccess={true}
          allowFileAccessFromFileURLs={true}
          allowUniversalAccessFromFileURLs={true}
          onMessage={handleMessage}
          onLoadEnd={() => {
            console.log('WebView loaded');
            if (serverReady) {
              setStatus('WebView loaded - Ready for testing');
            } else {
              setStatus('WebView loaded - Waiting for server...');
            }
          }}
          injectedJavaScript={`
            // Forward console logs to React Native
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;

            console.log = function(...args) {
              originalLog.apply(console, args);
              window.ReactNativeWebView?.postMessage(JSON.stringify({
                type: 'console',
                level: 'log',
                message: args.join(' ')
              }));
            };

            console.error = function(...args) {
              originalError.apply(console, args);
              window.ReactNativeWebView?.postMessage(JSON.stringify({
                type: 'console',
                level: 'error',
                message: args.join(' ')
              }));
            };

            console.warn = function(...args) {
              originalWarn.apply(console, args);
              window.ReactNativeWebView?.postMessage(JSON.stringify({
                type: 'console',
                level: 'warn',
                message: args.join(' ')
              }));
            };

            // Override document.addEventListener to handle messages from React Native
            const originalAddEventListener = document.addEventListener;
            const documentMessageHandlers = [];

            document.addEventListener = function(event, handler, options) {
              originalAddEventListener.call(this, event, handler, options);
              if (event === 'message') {
                documentMessageHandlers.push(handler);
              }
            };

            // Override window.addEventListener to capture message handlers
            const originalWindowAddEventListener = window.addEventListener;
            const windowMessageHandlers = [];

            window.addEventListener = function(event, handler, options) {
              originalWindowAddEventListener.call(this, event, handler, options);
              if (event === 'message') {
                windowMessageHandlers.push(handler);
              }
            };

            // Function to trigger message events when React Native sends data
            window.triggerMessageEvent = function(data) {
              const messageEvent = new MessageEvent('message', {
                data: data,
                origin: 'react-native',
                source: window
              });

              // Trigger both window and document message handlers
              windowMessageHandlers.forEach(handler => {
                try {
                  handler(messageEvent);
                } catch (e) {
                  console.error('Error in window message handler:', e);
                }
              });

              documentMessageHandlers.forEach(handler => {
                try {
                  handler(messageEvent);
                } catch (e) {
                  console.error('Error in document message handler:', e);
                }
              });
            };

            true; // Required return value
          `}
          onError={(error) => {
            console.error('WebView error:', error);
            setStatus('WebView error');
          }}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#1a1a2e',
  },
  header: {
    backgroundColor: '#2a2a3e',
    padding: 20,
    paddingTop: 50,
    borderBottomWidth: 1,
    borderBottomColor: '#3a3a4e',
  },
  title: {
    color: 'white',
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  status: {
    color: '#4ecdc4',
    fontSize: 16,
    marginBottom: 5,
  },
  info: {
    color: '#888',
    fontSize: 14,
  },
  webview: {
    flex: 1,
    backgroundColor: 'transparent',
  },
});
